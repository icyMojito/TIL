## # 객체지향 프로그래밍

#### 다형성

- 여러 가지 형태를 가질 수 있는 능력. 자바에서는 한 타입의 참조변수로 여러 타입의 객체를 참조할 수 있도록 함으로써 구현

  - 조상 클래스 타입의 참조변수로 자손 클래스의 인스턴스를 참조할 수 있도록 함. 이 경우 조상 클래스의 멤버만 사용 가능

    자손 클래스 타입의 참조변수로 조상 클래스의 인스턴스를 참조할 수 없음. 자손 클래스의 멤버가 더 많기 때문



#### 참조변수의 형변환

- 서로 상속관계에 있는 클래스 사이에서만 가능 (먼 조상, 먼 자손 가능)
- 자손타입의 참조변수를 조상타입의 참조변수로, 그 반대의 형변환도 가능
- 같은 조상 클래스를 가진 자손 클래스끼리는 형변환 불가능
- **instanceof 연산자**
  - 참조변수가 참조하고 있는 인스턴스의 실제 타입을 확인
  - 주로 조건문에 사용됨
  - 왼쪽에는 참조변수를, 오른쪽에는 타입(클래스명)이 피연산자로 위치
  - 연산의 결과는 boolean값인 true 혹은 false를 반환
- 조상타입의 참조변수 배열을 사용하면 공통의 조상을 가진 다른 종류의 객체를 배열로 묶을 수 있음



#### 추상 클래스

- 미완성 메서드 = 추상 메서드를 포함하고 있다는 의미
  - 생성자, 멤버변수, 메서드 모두 가질 수 있음
- 미완성 설계도나 마찬가지라서 인스턴스 생성 불가
- _조상 클래스로서 기능_
- 클래스 선언부에 키워드 'abstract'를 붙임 



#### 추상 메서드

- 선언부만 작성하고 구현부는 작성하지 않은 미완성 메서드

- 구현부의 실제 내용은 상속받는 클래스에서 오버라이딩으로 구현

  > /* 주석을 통해 어떤 기능을 수행할 목적으로 작성하였는지 설명 */
  >
  > Abstract 리턴타입 메서드이름();

- 조상의 추상 메서드 중 하나라도 구현하지 않으면 자손클래스 역시 추상클래스로 지정해야 함



#### 상속 vs 추상

- 구체화 vs 추상화
- 자손 클래스를 만드는데 조상 클래스를 사용 vs 기존 클래스의 공통부분을 뽑아내서 조상 클래스를 만드는 것



#### 인터페이스

- 추상화 정도가 높은 일종의 추상클래스로 추상메서드를 가짐

  - 추상 메서드와 상수만 가질 수 있음
  - 일반 메서드나 멤버 변수를 가질 수 없음

  > interface 인터페이스이름 {
  >
  > ​       public static final 타입 상수이름 = 값;
  >
  > ​       public abstract 메서드이름(매개변수목록);
  >
  > }

  - - 멤버 변수의 public static final과 메서드의 public abstract는 생략하여도 컴파일러가 자동적으로 추가함

- **상속**

  - 인터페이스로부터만 상속받을 수 있음

  - 다중 상속이 가능 (","로 구분)

    > interface A extends B, C {}

- **구현**

  - 인스턴스를 생성할 수 없으므로 자신을 상속받는 클래스에서 완성됨

  - 키워드 'implements' > 구현하다

    > class 클래스이름 implements 인터페이스이름 { }

  - _구현하는 인터페이스의 메서드 중 일부만 구현할 경우 추상 클래스로 선언해야 함_

  - 상속과 동시에 구현 가능

    > class 클래스이름 extends 조상클래스 implements 인터페이스이름 { }

- **다형성**

  - 인터페이스 타입의 참조변수로 이를 구현한 클래스의 인스턴스 참조와 인터페이스 타입으로의 형변환도 가능
  - 인터페이스는 메서드의 매개변수의 타입으로도 사용 가능
    - 해당 인터페이스를 구현한 클래스의 인스턴스가 매개변수로 제공됨
  - 인터페이스는 메서드의 리턴타입으로도 지정 가능
    - 해당 인터페이스를 구현한 클래스의 인스턴스를 반환해야 함

- **장점**

  1. _개발시간 단축_ : 하나의 인터페이스로 동시에 개발 가능
  2. _표준화_ : 프로젝트에 사용하는 기본 틀로 활용. 일관되고 정형화된 프로그램의 개발이 가능
  3. _서로 관계없는 클래스끼리 관계 형성 가능_ : 상속관계도 아니고 공통 조상이 없어도 인터페이스 구현을 통해 관계 형성
  4. _독립적인 프로그래밍_ : 클래스 간의 직접적인 관계를 간접적인 관계로 변경하여 서로 독립적인 프로그래밍이 가능

- **디폴트 메서드**

  - 추상 메서드가 아닌 메서드로 인터페이스에 추가되어도 구현한 클래스들이 구현하지 않음

  - 인터페이스에 메서드 추가 = 추상 메서드 추가 = 구현한 클래스들이 새로 추가된 메서드를 구현해야 하는 부담을 줄임

    > interface 인터페이스명 {
    >
    > ​      void method();   _// public abstract가 생략됨_
    >
    > ​      **default void newMethod() {  };   _// public이 생략됨_**
    >
    > }

  - 디폴트 메서드와 기존의 메서드의 이름 중복으로 충돌이 발생했을 때

    - 인터페이스 간의 디폴트 메서드 이름 충돌 - 구현한 클래스에서 디폴트 메서드를 오버라이딩
    - 디폴트 메서드와 조상 클래스의 메서드 이름 충돌 - 조상 클래스의 메서드가 상속되고 디폴트 메서드는 무시됨



#### 내부 클래스

- 클래스 내에 선언된 클래스 (긴밀한 관계)
- **장점**
  - 내부 클래스에서 외부 클래스의 멤버들에게 쉽게 접근 가능
  - 외부에 불필요한 클래스를 내부로 감추어 코드의 복잡성을 줄임 ➤ 캡슐화

| 내부 클래스 종류 | 특징                                                         |
| ---------------- | ------------------------------------------------------------ |
| 인스턴스 클래스  | 외부 클래스의 멤버변수 선언위치에 선언<br>외부 클래스의 인스턴스 멤버처럼 다루어짐<br>외부 클래스의 인스턴스 멤버들과 관련된 작업에 사용될 목적 |
| 스태틱 클래스    | 외부 클래스의 멤버변수 선언위치에 선언<br/>외부 클래스의 static 멤버처럼 다루어짐<br/>외부 클래스의 static 멤버, 특히 static 메서드에서 사용될 목적 |
| 지역 클래스      | 외부 클래스의 메서드나 초기화블럭 안에 선언<br>선언된 영역 내부에서만 사용 |
| 익명 클래스      | 클래스의 선언과 객체의 생성을 동시에 하는 이름없는 일회용 클래스 |



- **제어자와 접근성**
  - 인스턴스 클래스와 스태틱 클래스는 외부 클래스의 멤버변수와 같은 위치에 선언되고 멤버변수와 같은 성질을 가지며 인스턴스 멤버와 static 멤버 간의 규칙이 똑같이 적용됨
  - 멤버변수처럼 private, protected 같은 접근제어자 사용 가능
  - 클래스이므로 abstract나 final 같은 제어자 사용 가능
- **내부 클래스 안의 static 멤버**
  - 내부 클래스 중 스태틱 클래스만 가질 수 있음
  - 상수(final static이 붙은 변수)는 모든 내부 클래스에서 정의 가능
- **지역 클래스의 멤버 사용**
  - 외부 클래스의 인스턴스 멤버, static 멤버 모두 사용 가능
  - 지역 클래스가 포함된 외부 클래스의 메서드에 정의된 지역변수 중 final이 붙은 지역변수만 사용 가능
    - 메서드가 수행을 마쳐 지역변수가 소멸된 시점에도 지역 클래스의 인스턴스가 참조하려고 시도할 수 있기 때문
- **변수 이름 사용**
  - 내부 클래스와 외부 클래스에 선언된 변수의 이름이 같으면 'this' 또는 '_외부 클래스명.this_'를 붙여서 구별



#### 익명 클래스

- 내부 클래스
- 이름이 없으며 클래스의 선언과 객체의 생성이 동시에 이루어짐
- 오직 하나의 객체만 생성할 수 있는 일회용 클래스
- 이름이 없어 생성자도 없음
- 단 하나의 클래스를 상속받거나 단 하나의 인터페이스만 구현 가능