## # 객체지향 프로그래밍

- 객체지향언어의 가장 큰 장점은 **'코드의 재사용성이 높고 유지보수가 용이'**한 점

- **클래스** : 객체를 정의해 놓은 것이며 따라서 객체를 생성하는데 사용

  - 하나의 소스파일에 둘 이상 클래스를 정의할 때 소스파일의 이름은 public class의 이름과 일치해야 함

    단 public class는 반드시 한 개만 존재

    public class가 없다면 소스파일 내의 클래스 이름 중 무엇이든 소스파일의 이름이 될 수 있음

  - 데이터와 함수의 결합 : 데이터 처리를 위한 데이터 저장형태

  - 사용자 정의 타입 : 프로그래머가 서로 관련된 변수들을 묶어서 하나의 타입으로 새로 추가

- **객체** : 프로그래밍에서는 클래스에 정의된 내용대로 메모리에 생성되어 실제로 존재하는 것

  - 구성요소 ← 객체의 멤버

    - **속성(property) = 멤버변수(variable)**

      - 변수의 초기화
    
        / 변수를 선언하고 처음으로 값을 저장하는 것
    
        / 멤버변수(클래스, 인스턴스 변수)는 별도의 초기화가 없어도 자동적으로 자료형에 맞는 기본값으로 초기화

          지역변수는 사용하기 전에 반드시 초기화 필요

      - 멤버변수의 초기화

        1. 클래스 변수 초기화(클래스가 처음 로딩될 때 단 한 번) 

           ​														→ 인스턴스 변수 초기화(인스턴스 생성 시마다 각 인스턴스 별로)

        2. 자동 초기화(기본값) → 명시적 초기화(간단) → 초기화 블럭, 생성자(복잡)
    
           / 명시적 초기화 : 변수를 선언과 동시에 초기화. 가장 기본적이면서 간단한 방법
    
           / 초기화 블럭 : 클래스 초기화 블럭(static{}, 처음 메모리에 로딩될 때 한 번만 수행), 
    
           ​					   인스턴스 초기화 블럭({}, 인스턴스가 생성될 때마다 가장 먼저 수행)
    
    | 변수의 종류   | 선언위치                                                     | 생성시기                    |                                                              |
    | ------------- | ------------------------------------------------------------ | --------------------------- | ------------------------------------------------------------ |
    | 클래스 변수   | 클래스 영역                                                  | 클래스가 메모리에 올라갈 때 | 공통 속성. 인스턴스 변수 앞에 static을 붙임<br> 모든 인스턴스가 공통된 저장공간(변수)을 공유<br> 인스턴스 생성없이도 사용 가능 <br>('클래스이름.클래스변수') |
  | 인스턴스 변수 | 클래스 영역                                                  | 인스턴스가 생성되었을 때    | 개별 속성                                                    |
    | 지역변수      | 클래스 영역 이외의 영역<br>- 메서드, 생성자, 초기화 블럭 내부 | 변수 선언문이 수행되었을 때 | 메서드 내에 선언되어 메서드 내에서만 사용 가능<br>메서드가 종료되면 소멸 <br>메서드의 매개변수도 지역변수<br>서로 다른 메서드라면 같은 이름의 변수 사용이 가능하다. |

    - **기능(function) = 메서드(method)**
    
      - 특정 작업을 수행하는 일련의 문장들을 하나로 묶은 것
    
      - 메서드 정의 : 선언부와 구현부를 작성하는 것

      - 선언부

        > **반환타입(출력)  메서드이름  매개변수선언(입력)**
      >
        > ​           int                  add             (int x, int y)        {
        >
        > ​	int result = x + y;
        >
        > ​	return result;
        >
        > }
        >
        > **// 반환값이 없는 경우 반환타입으로 'void' 사용**
    
      - 구현부
    
        > **{} 안에 'return 반환값'이 반드시 포함**
        >
        > **반환값의 타입은 반환타입과 일치하거나 적어도 자동 형변환이 가능해야 함** 
        >
        > // 반환타입이 'void'면 반환값이 없으며 컴파일러가 마지막에 return;을 자동 추가
    
      - 선언부의 매개변수는 복수가 가능하나 구현부의 반환값은 하나만 허용
    
      - 특정 메서드 호출 시 괄호() 안에 지정해준 값인 '인자'의 타입, 개수, 순서는 메서드에 선언된 매개변수의 타입, 개수, 순서와 일치해야 함
    
      - 기본형 매개변수
    
        / 기본형 값이 복사되기 때문에 단순히 저장된 값만 얻으며 원본에는 영향이 없음
    
      - 참조형 매개변수
    
        / 인스턴스 주소가 복사되기 때문에 값이 저장된 곳의 주소를 알 수 있으므로 원본 값을 읽고, 변경할 수 있음 
    
      - 참조형 반환타입
    
        / 반환하는 값의 타입이 참조형. 모든 참조형 타입의 값은 '객체의 주소'이므로 정수값이 반환
    
        | 클래스 메서드                                                | 인스턴스 메서드                                              |
        | :----------------------------------------------------------- | ------------------------------------------------------------ |
        | 메서드 앞에 static이 붙음                                    |                                                              |
        | 객체 생성 없이 '클래스이름.메서드이름(매개변수)'로 호출 가능 | 반드시 객체 생성해야 호출 가능                               |
        | 인스턴스 멤버와 관계없는 메서드                              | 메서드 작업 수행 시 인스턴스 변수를 필요로 함                |
        | 인스턴스 변수 사용이 불가능                                  | static 멤버 사용 가능                                        |
        | 메서드 호출 시간이 짧음                                      |                                                              |
        | 같은 클래스에 속할 때 인스턴스 멤버를 참조, 호출하려면 인스턴스 생성이 필요 | 같은 클래스에 속할 때 인스턴스 생성 없이 인스턴스 멤버와 static 멤버 모두 참조, 호출 가능 |
    
    
    
    
    - **오버로딩** : 한 클래스 내에 같은 이름의 메서드를 여러 개 정의하는 것
    
      ​				_조건 1_. 메서드 이름이 같아야 한다.
    
      ​				_조건 2_. 매개변수의 개수 또는 타입이 달라야 한다. 개수와 타입이 같아도 순서가 다르면 오버로딩이다.
    
      ​				_유의점_. 반환 타입은 오버로딩 구현에 아무런 영향이 없다.
    
      > 대표적인 오버로딩 메서드 : PrintStream 클래스의 println() 메서드
    
    - **호출스택** : 호출된 메서드의 작업에 필요한 메모리 공간을 제공. 메서드가 작업을 마치면 할당되었던 메모리 공간은 반환된다. 클래스를 실행하면 JVM에 의해서 main 메서드가 호출되고 프로그램이 시작된다. 이 때, 호출스택에는 main 메서드를 위한 메모리 공간(메서드 작업 수행 동안 지역변수와 연산의 중간 결과 등을 저장하는데 사용)이 할당되고 main 메서드의 코드가 수행되기 시작한다. main 메서드에서 다른 메서드를 호출한 경우 main 메서드는 대기상태로 남아있고 다른 메서드가 호출되어 수행이 완료되면 호출스택에서 사라진다. 그리고 자신을 호출한 main 메서드로 되돌아가 대기 중이던 main 메서드는 수행을 재개한다. main 메서드의 수행이 완료되면 호출스택은 완전히 비워지게 되고 프로그램은 종료된다.
    
    

- **인스턴스** : 어떤 클래스로부터 만들어진 객체 (예시: Test클래스의 인스턴스)

|                 객체                 |                  인스턴스                   |
| :----------------------------------: | :-----------------------------------------: |
| 모든 인스턴스를 대표하는 포괄적 의미 | 어떤 클래스로부터 만들어진 것인지 보다 강조 |
|           '책상은 객체다'            |      '책상은 책상 클래스의 인스턴스다'      |

- 클래스로부터 인스턴스 생성

  > **클래스명 변수명; **  // 클래스의 객체를 참조하기 위한 참조변수 선언
  >
  > **변수명 = new 클래스명(); **   // 클래스의 객체를 생성 후 객체의 주소를 참조변수에 저장
  >
  > ​                                                // 멤버변수는 각 자료형에 해당하는 기본값으로 초기화

  - 인스턴스는 참조변수를 통해서만 다룰 수 있으며 참조변수의 타입은 인스턴스의 타입과 일치해야 함

- **객체배열** : 객체의 주소인 참조변수들의 배열. _반드시 객체를 생성해서 객체 배열의 각 요소에 저장해야 함_

  > Tv[] tvArr = new Tv[100];
  >
  > for (int i=0; i<tvArr.length; i++) {
  >
  > ​	tvArr[i] = new Tv();
  >
  > }



- **생성자** : 인스턴스가 생성될 때 호출되는 '<u>인스턴스 초기화(인스턴스 변수 초기화) 메서드</u>'로 오버로딩이 가능

  ​			 _조건 1._ 생성자의 이름은 클래스의 이름과 같아야 한다.

  ​			 _조건 2._ 생성자는 리턴 값이 없다.

  ​			 _유의점._ 생성자 앞에 void를 사용하지 않으며, 생성자가 인스턴스를 생성하는 것이 아니다.

  ​						 모든 클래스에는 반드시 하나 이상의 생성자가 정의되어야 한다.

  - 기본 생성자

    / 소스파일의 클래스에 생성자 정의가 하나도 없을 경우 컴파일러가 자동으로 추가해주는 생성자

    > 클래스이름() { }
    >
    > public 클래스이름() { }   // 클래스의 접근 제어자가 public인 경우

    - 매개변수를 갖는 생성자

      / 인스턴스를 생성하는 동시에 원하는 값으로 초기화를 할 수 있어 코드를 보다 간결하고 직관적으로 만듦

    - 생성자에서 다른 생성자 호출하기

      / 같은 클래스 내의 생성자들은 서로 관계가 깊은 경우가 많아서 유기적으로 연결해주면 유지보수가 쉬워짐

      ​	_조건1._ 생성자의 이름으로 클래스이름 대신 this를 사용

      ​	_조건2._ 한 생성자에서 다른 생성자를 호출할 때는 반드시 첫 줄에서만 호출이 가능

      ​				/ 초기화 작업 도중 다른 생성자를 호출하면 이전의 초기화 작업이 무의미해질 수 있음

      > Class Car2 {
      >
      > ​	String color; String gearType; int door;
      >
      > ​	Car2() { this("white", "auto", 4); }
      >
      > ​	Car2(Strign color) { this(color, "auto", 4); }
      >
      > ​	Car2(String color, String gearType, int door) {
      >
      > ​		this.color = color; this.gearType = gearType; this.door = door;	
      >
      > ​	}
      >
      > }

    - **객체 자신을 가리키는 참조변수 this**

      / 인스턴스 자신을 가리키는 참조변수, 인스턴스의 주소가 저장되어 있음. 모든 인스턴스 메서드에 지역변수로 숨겨진 채 존재. 인스턴스멤버만 사용 가능. 생성자의 매개변수로 인스턴스변수들의 초기값을 제공받을 때 매개변수와 인스턴스변수의 이름이 일치하면 인스턴스변수 앞에 this를 붙여 구별

      / this(), this(매개변수) : 생성자, 같은 클래스의 다른 생성자를 호출할 때 사용



- **package**

  - 클래스의 묶음. 인터페이스도 포함 가능

  - 클래스의 실제 이름(full name)은 패키지명이 포함됨

  - 패키지 선언하기

    > package 패키지명;

    - 반드시 소스파일에서 첫 번째 문장이어야 함
    - 하나의 소스파일에 단 한 번만 선언
    - 패키지명은 소문자로 하는 것이 원칙

  - 패키지를 지정하지 않은 클래스는 자바에서 제공하는 '이름 없는 패키지(unnamed package)'에 자동으로 속함

  - 큰 프로젝트, 클래스 라이브러리 작성 시 패키지 적용 필수



- **import**

  - 소스 파일에서 사용하고자 하는 클래스의 패키지에 대한 정보를 제공

  - 임포트 선언하기

    > import 패키지명.클래스명;
    >
    > import 패키지명.*;

    - package문 다음에 위치
    - 클래스명 대신 *을 사용해도 실행 시 성능상의 차이는 없음

  - **static import문**

    > import _static_ java.lang.System.out;
    >
    > out.println("***");

    - static 멤버를 호출할 때 클래스 이름 생략 가능

  - java.lang 패키지

    - 자바 프로그래밍에 가장 기본이 되는 클래스들을 포함
    - 이 패키지의 클래스들은 import문 없이도 사용 가능

    

- **제어자**

  - 클래스, 변수 또는 메서드의 선언부에 함께 사용되어 부가적인 의미를 부여

  - 하나의 대상에 여러 제어자를 조합하여 사용 가능

    - 접근 제어자는 하나만 사용 가능

    | 접근 제어자                         | 그 외                                                        |
    | ----------------------------------- | ------------------------------------------------------------ |
    | public, protected, default, private | _static, final, abstract,_ native, transient,<br/> synchronized, volatile, strictly |

- - **static**

    - '클래스의', '공통적인'
    - 멤버변수, 메서드, 초기화 블럭에 사용
    - 인스턴스에 관계없이 같은 값을 가져야 하는 요소에 붙임
    - 인스턴스를 생성하지 않고도 사용 가능
    - 인스턴스 멤버를 사용하지 않는 메서드는 static을 붙여야 호출이 편리하고 속도도 빠름

  - **final**

    - '마지막의', '변경될 수 없는'

    - 클래스, 메서드, 멤버변수, 지역변수에 사용

      | 클래스                    | 메서드            | 변수           |
      | ------------------------- | ----------------- | -------------- |
      | 다른 클래스의 조상 불가능 | 오버라이딩 불가능 | 값 변경 불가능 |

  - **abstract**

    - '미완성'
    - 클래스, 메서드에 사용
    - 추상 메서드 선언, 추상 클래스 표시

  - **접근 제어자의 접근 범위**

    |  제어자   | 같은 클래스 | 같은 패키지 | 자손클래스 | 전체 |
    | :-------: | :---------: | :---------: | :--------: | :--: |
    |  public   |      O      |      O      |     O      |  O   |
    | protected |      O      |      O      |     O      |      |
    | (default) |      O      |      O      |            |      |
    |  private  |      O      |             |            |      |

  - **접근 제어자의 사용 이유**

    - 클래스의 내부에 선언된 데이터를 외부로부터 보호하기 위해 사용 > 데이터 감추기(data hiding)

    - 외부에는 불필요한, 클래스 내에서만 사용되는 멤버변수나 메서드를 클래스 내부에 감추기

      ➤ _객체지향개념의 캡슐화(encapsulation)_



- **getter** : get으로 시작되는 메서드
- **setter** : set으로 시작되는 메서드



### ▣ 참조 링크

- https://meetup.toast.com/posts/106